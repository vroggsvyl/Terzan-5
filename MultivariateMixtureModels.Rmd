---
title: "Multivariate Mixture Models"
output: html_document
date: "2024-04-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Importing the Data
```{r}
library(here)
i_am("MultivariateMixtureModels.Rmd")
# laptop data from csv
Terzan5 <- readr::read_csv(here("Data", "Terzan 5 X-ray events.csv"), col_types = list(.default = readr::col_guess()), )
# head(Terzan5)

#fishbowl data from ODS
# library(readODS)
# Terzan5 <- read_ods(here("Raw Data.ods"), col_types = list(.default = readr::col_guess()), )
#removing extraneous columns
T5 <- data.frame(Terzan5$x, Terzan5$y)
colnames(T5) <- c('x','y')

library(ggplot2)
library(ggpointdensity)
library(viridis)

ggplot(T5,aes(x,y)) + 
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") + 
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(10, 100, 1000, 10000)) + 
  coord_fixed()
```
Filtering down to area of interest
```{r}
library(tidyr)
library(plotly)
interestArea <- T5 %>%
  filter(x>4100 & x<4150 & y>4025 & y<4075)

ggplot(interestArea,aes(x,y)) + 
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") + 
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) + 
  coord_fixed()
```

```{r}
interestArea2 <- T5 %>%
  filter(x>4105 & x<4135 & y>4160 & y<4190)

ggplot(interestArea2,aes(x,y)) + 
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") + 
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) + 
  coord_fixed()

```
```{r}
interestArea2S1 <- interestArea2 %>%
  filter(x>4110 & x<4120 & y>4177 & y<4187)

interestArea2S2 <- interestArea2 %>%
  filter(x>4124 & x<4134 & y>4173 & y<4183)

nrow(interestArea2S1)
nrow(interestArea2S2)
```


```{r}
ggplot(interestArea,aes(x,y)) +
  geom_point(size = 0.5)
```


There is three clearly evident celestial sources in this area.
There are two small areas that could also be celestial sources (located above and below the highest definitive source).

I will be attempting to fit a multivariate mixture model for the entire area. The model will contain three(?) individual 2D Moffat distributions.

The lowest and densest source has already been modelled individually and is denoted as POI2 in previous Rmarkdown files. 

```{r}
library(mixtools)

set.seed(111)
data1 <- cbind(rnorm(100, mean = 0, sd = 1), rnorm(100, mean = 0, sd = 1))
data2 <- cbind(rnorm(100, mean = 5, sd = 1), rnorm(100, mean = 5, sd = 1))

datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
par(pty = "s")
plot(datafull)

fit <- mvnormalmixEM(datafull, k = 2)

names(fit)

fit$lambda
fit$mu
fit$sigma

fit$loglik
#fit$posterior
fit$all.loglik
fit$restarts

par(pty = "s")
plot.mixEM(fit, whichplots = 2)
plot.mixEM(fit, whichplots = 1)
```
From the results 

lambda returns the weightings of each cluster

The mean location of the first cluster (red) is (-0.012, -0.016) 
The mean location of the second cluster (green) is (5.14, 5.02)

Sigma returns the covariance matrixes

```{r}
trial <- mvnormalmixEM(interestArea, k = 3)
```

```{r}
par(pty = "s")
plot.mixEM(trial, whichplots = 2)
```
```{r}
plot.mixEM(trial, whichplots = 1)
trial$lambda
trial$mu
trial$sigma
```

```{r}
library(mixAK)
NMixEM(datafull, K = 2)
```
This returns the same values as the mixtools packages - however it displays it in a much neater way.

Mean Vector and Covariance Matrix
```{r}
set.seed(222)
randomMatrix <- matrix(rnorm(10), nrow = 5)
randomMatrix

colMeans(randomMatrix)
cov(randomMatrix)
```
```{r}
#generate random cluster 2
set.seed(224)
randomMatrix2 <- matrix(rnorm(500, mean = 3, sd = 0.4), nrow = 250)
mean2 <- colMeans(randomMatrix2)
covmat2 <- cov(randomMatrix2)
det2 <- det(covmat2)

#generate random cluster 3
set.seed(225)
randomMatrix3 <- matrix(rnorm(500, mean = 1, sd = 0.2), nrow = 250)
mean3 <- colMeans(randomMatrix3)
covmat3 <- cov(randomMatrix3)
det3 <- det(covmat3)

#asign a random point somewhere in the region
z <- matrix(c(3, 3.2), nrow = 1)
```
```{r}
plot(randomMatrix2[,1], randomMatrix2[,2], xlim = c(-2, 5), ylim = c(-2, 5))#random cluster 2
points(randomMatrix3[,1], randomMatrix3[,2], col = "red")#random cluster 3
```

```{r}
randomClusters <- rbind(randomMatrix2, randomMatrix3)
fit1 <- mvnormalmixEM(randomClusters, k = 2)
fit1
plot.mixEM(fit1, whichplots = 2)
points(z[,1], z[,2], col = "blue") #random point - what's the density of this point if it exists in either cluster?
fit2 <- NMixEM(randomClusters, K= 2)
fit2
```
The parameters have been estimated using a spatial mixture model - I want to know associated density of a random point z. where z is (2,1)
```{r}
#Using the estimated parameters
c1 <- exp(-0.5*(z-fit1$mu[[1]]) %*% solve(fit1$sigma[[1]]) %*% t(z-fit1$mu[[1]]))/(2*pi*sqrt(det(fit1$sigma[[1]])))

c2 <- exp(-0.5*(z-fit1$mu[[2]]) %*% solve(fit1$sigma[[2]]) %*% t(z-fit1$mu[[2]]))/(2*pi*sqrt(det(fit1$sigma[[2]])))
c1
c2
fit1$lambda[[1]]*c1+fit1$lambda[[2]]*c2
```

```{r}
#Using the known data
p1 <- (1/(2*pi*sqrt(det2)))*exp(-0.5*(z-mean2) %*% solve(covmat2) %*% t(z-mean2)) #component density if existing in cluster 2
p2 <- (1/(2*pi*sqrt(det3)))*exp(-0.5*(z-mean3) %*% solve(covmat3) %*% t(z-mean3)) #component density if existing in cluster 3
pz <- 0.5*p1 + 0.5*p2 #component density of existing in either cluster
p1
p2
pz
```


I want to create a rmoffat function
First try to create a rnorm function so I've got something to compare to and make sure I'm on the right track.
Goal: obtain an inverse of the CDF

```{r}
iCDF <- function(y, mean, sd){
  qnorm(p = y, mean, sd)
}

yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)

y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)

iCDFMOFFAT <- function(y, params){
  qmoffat(p = y, params)
  return(Vectorize(qmoffat, vectorize.args = "p"))
}

params <- c(0,0,1,2)
#iCDFMOFFAT(y, params)

Vqmoffat(0.5, params)
```


```{r}
x <- runif(10, min = 0, max = 1)


x
mu <- 0
sigma <- 1
#xRange <- seq(-3, 3, length = 20)

#(exp(-0.5*((xRange-mu)/sigma)^2))/(sigma*sqrt(2*pi))

randNorm <- function(x, mu, sigma){
  return((exp(-0.5*((x-mu)/sigma)^2))/(sigma*sqrt(2*pi)))
}

a <- randNorm(x, 0, 1)
a

qnorm(a, mean = 0, sd = 1)

#(gamma(beta)/(alpha*sqrt(pi)*gamma(beta-0.5)))*(1+((x-mu)/alpha)^2)^-beta
```


Creating a mixture model that uses two 2D moffat functions. 
$$ f(y_j) = \sum^{2}_{i=1} \lambda_i f_i(y_j)$$
Where $\lambda_i$ is the mixing proportion parameter and $f_i(y_j)$ are the component densities. Which in the case of a moffat density looks like this.
$$f_i(y_j) = \frac{\beta_i-1}{\pi\alpha_i^2}\left[1 + \frac{(x_j-\bar{x}_{i})^2 + (y_j - \bar{y}_{i})^2}{\alpha_i^2}\right]^{-\beta_i} $$
The mixture model in full:
$$ f(y_j) = \lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}$$
Let $ v_i = 1 + \frac{(x_j-\bar{x}_{i})^2 + (y_j - \bar{y}_{i})^2}{\alpha_i^2} $
Let $ c_i = \frac{(\beta_i-1)}{\pi\alpha_{i}^{2}} $

$$ f(y_j) = \lambda_1 c_1 v_1^{-\beta_1} + \lambda_2 c_2 v_2^{-\beta_2}$$

```{r}
MM2MOFFAT <- function(params, x, y){
  #component density 1
  lambda1 <- params[[1]]
  x1 <- params[[2]]
  y1 <- params[[3]]
  alpha1 <- params[[4]]
  beta1 <- params[[5]]
  #component density 2
  #lambda2 <- params[[6]]
  x2 <- params[[6]]
  y2 <- params[[7]]
  alpha2 <- params[[8]]
  beta2 <- params[[9]]
  
  #restrictions
  alpha1 <- pmax(alpha1, 1e-6)
  beta1 <- pmax(beta1, 1 + 1e-6)
  alpha2 <- pmax(alpha2, 1e-6)
  beta2 <- pmax(beta2, 1 + 1e-6)
  
  lambda1 <- pmin(lambda1, 1)
  lambda1 <- pmax(lambda1, 0)
  lambda2 = 1 - lambda1
  
  c1 <- (beta1 - 1)/(pi*alpha1^2)
  c2 <- (beta2 - 1)/(pi*alpha2^2)
  v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
  v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
  
  return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}

library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
```
When integrating the function over the entire range it should equate to 1 - this is tricky to evaluate due to how R handles integration.

```{r}
MM2MOFFATimage <- function(grid, params){
  x <- grid[[1]]
  y <- grid[[2]]
  
  #component density 1
  lambda1 <- params[[1]]
  x1 <- params[[2]]
  y1 <- params[[3]]
  alpha1 <- params[[4]]
  beta1 <- params[[5]]
  #component density 2
  lambda2 <- params[[6]]
  x2 <- params[[7]]
  y2 <- params[[8]]
  alpha2 <- params[[9]]
  beta2 <- params[[10]]
  
  #restrictions
  alpha1 <- pmax(alpha1, 1e-6)
  beta1 <- pmax(beta1, 1 + 1e-6)
  alpha2 <- pmax(alpha2, 1e-6)
  beta2 <- pmax(beta2, 1 + 1e-6)
  
  lambda1 <- pmin(lambda1, 1)
  lambda1 <- pmax(lambda1, 1 - lambda2)
  lambda2 <- pmin(lambda2, 0 + lambda1)
  lambda2 <- pmax(lambda2, 1 - lambda1)
  
  c1 <- (beta1 - 1)/(pi*alpha1^2)
  c2 <- (beta2 - 1)/(pi*alpha2^2)
  v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
  v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
  
  return(lambda1*c1*v1^(-beta1) + 
  lambda2*c2*v2^(-beta2))
}

xRange <- seq(-20, 20, length = 200)
yRange <- seq(-20, 20, length = 200)
grid <- expand.grid(xRange, yRange)

testParams3 <- c(lambda1 = 0.55, x1 = -5, y1 = -4, alpha1 = 1.2, beta1 = 2, lambda2 = 0.45, x2 = 10, y2 = 2, alpha2 = 1.2, beta2 = 2)


z3 <- MM2MOFFATimage(params = testParams3, grid)
z3Matrix <- matrix(z3, nrow = length(xRange), ncol = length(yRange))
image(xRange, yRange, z3Matrix)
```



The Negative Log-Likelihood of the Mixture Model containing 2 Moffat component densities.
$$-\sum^{n}_{j=1}\ln\left[\lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}\right]$$


$$-\sum^{n}_{j=1}\ln\left[\lambda_1 c_1 v_1^{-\beta_1} + \lambda_2 c_2 v_2^{-\beta_2}\right]$$

```{r}
NLLMM2MOFFAT <- function(params, x, y){
  predictedDens <- MM2MOFFAT(params, x, y)
  return(-sum(log(predictedDens)))
}
```

To find the partial derivatives of the Negative Log Likelihood
Throughout the derivations the chain rule, quotient rule and product rule are utilised
Chain Rule: $\frac{\partial}{\partial x} = \frac{\partial}{\partial y} \frac{\partial y}{\partial x} $
Quotient Rule: $\frac{\partial}{\partial x} = \frac{ v \frac{\partial u}{\partial x} - { u \frac{\partial v}{\partial x}}}{v^2} $
Product Rule:  $\frac{\partial (uv)}{\partial x} = u \frac{\partial v}{\partial x} + { v \frac{\partial u}{\partial x}}$

Let:
$$ u = \lambda_1 c_1 v_1^{-\beta_1} + \lambda_2 c_2 v_2^{-\beta_2} $$

For $\frac{\partial}{\partial x_1}$:

$$\frac{\partial}{\partial x_1} = \frac{\partial}{\partial u} \frac{\partial u}{\partial v_1} \frac{\partial v_1}{\partial x_1}$$
$$\frac{\partial}{\partial u} = -\sum\frac{1}{u}$$
$$\frac{\partial u}{\partial v_1} = - \lambda_1 c_1 \beta_1 v_{1}^{-(\beta_1 + 1)}$$
$$\frac{\partial v_1}{\partial x_1} = \frac{-2(x_j - \bar{x}_1)}{\alpha_{1}^{2}}$$
$$\frac{\partial}{\partial x_1} = -\sum\frac{1}{u} (-\lambda_1 c_1 \beta_1 v_{1}^{-(\beta_1 + 1)})(\frac{-2(x_j - \bar{x}_1)}{\alpha_{1}^{2}})$$
Simplifying to:
$$\frac{\partial}{\partial x_1} = -\sum\frac{2\lambda_1 c_1 \beta_1(x_j - \bar{x}_1)}{u  v_{1}^{\beta_1 + 1} \alpha_{1}^{2}}$$

A similar method is used to find the partial derivative with respect to $\bar{x}_2$, $\bar{y}_1$ and $\bar{y}_2$.

$$\frac{\partial}{\partial x_2} = -\sum\frac{2\lambda_2 c_2 \beta_2(x_j - \bar{x}_2)}{u  v_{2}^{\beta_2 + 1} \alpha_{2}^{2}}$$
$$\frac{\partial}{\partial y_1} = -\sum\frac{2\lambda_1 c_1 \beta_1(y_j - \bar{y}_1)}{u  v_{1}^{\beta_1 + 1} \alpha_{1}^{2}}$$

$$\frac{\partial}{\partial y_2} = -\sum\frac{2\lambda_2 c_2 \beta_2(y_j - \bar{y}_2)}{u  v_{2}^{\beta_2 + 1} \alpha_{2}^{2}}$$
For the partial derivative with respect to $\lambda_1$.
$$\frac{\partial u}{\partial \lambda_1} = c_1  v_{1}^{-\beta_1}$$
$$\frac{\partial}{\partial \lambda_1} = -\sum\frac{c_1 v_{1}^{-\beta_1}}{u}$$
Similarly for $\lambda_2$
$$\frac{\partial}{\partial \lambda_2} = -\sum\frac{c_2 v_{2}^{-\beta_2}}{u}$$

For the partial derivative with respect to $\alpha_1$
Let $w_1 = \frac{\lambda_1(\beta_1 -1)}{\pi}\alpha_{1}^{-2}$
Let $d_1 = v_1^{-\beta_1}$
So $u = wd$
Apply the product rule.

$w_1' = -2\frac{\lambda_1(\beta_1 - 1)}{\pi}\alpha_{1}^{-3}$

To find d' the quotient and chain rules are applied
$$d_1' = \frac{2 \beta_1\left[(x-x_1)^{2}+(y-y_1)^{2}\right]}{v_1^{\beta_1 +1}\alpha_1^3}$$

This can be simplified:
$$d_1' = \frac{2 \beta_1}{v_1^{\beta_1 +1}\alpha_1} \frac{\left[(x-x_1)^{2}+(y-y_1)^{2}\right]}{\alpha_1^2}$$
$$ = \frac{2 \beta_1}{v_1^{\beta_1} v_1 \alpha_1} v_1$$
$$ = \frac{2 \beta_1}{v_1^{\beta_1}\alpha_1}$$
Leading to:
$$\frac{\partial u}{\partial \alpha_1} = \frac{\lambda_1(\beta_1 -1)}{\pi\alpha_{1}^{2}} \frac{2 \beta_1}{v_1^{\beta_1}\alpha_1} + \frac{2 \lambda_1(\beta_1 - 1)}{\pi\alpha_{1}^{3}} \frac{1}{v_1^{\beta_1}}$$
This can be simplified:
$$\frac{\partial u}{\partial \alpha_1} = \frac{2 \lambda_1 \beta_1 (\beta_1 -1)}{\pi v_1^{\beta_1} \alpha_{1}^{3}} + \frac{2 \lambda_1(\beta_1 - 1)}{\pi v_1^{\beta_1} \alpha_{1}^{3}} $$
$$ = \frac{2 \lambda_1(\beta_1 - 1)}{\pi v_1^{\beta_1} \alpha_{1}^{3}} (\beta_1 + 1)$$
$$ = \frac{2 \lambda_1(\beta_1^2 - 1)}{\pi v_1^{\beta_1} \alpha_{1}^{3}}$$

Resulting in:
$$\frac{\partial}{\partial \alpha_1} = -\sum \frac{2 \lambda_1(\beta_1^2 - 1)}{\pi v_1^{\beta_1} \alpha_{1}^{3} u}$$

Similarly for $\alpha_2$
$$\frac{\partial}{\partial \alpha_2} = -\sum \frac{2 \lambda_2(\beta_2^2 - 1)}{\pi v_2^{\beta_2} \alpha_{2}^{3} u}$$

For the partial derivative with respect to $\beta_1$.
Rearrange the initial equation and
Let $s_i = \frac{\lambda_i}{\pi\alpha_{i}^{2}}$

$u = sv_{1}^{-\beta_1}(\beta_1 - 1)$
$$ u = sv_{1}^{-\beta_1}\beta_1 - sv_{1}^{-\beta_1}$$

The Product rule is employed to find the derivative of the first term.
$$\frac{\partial u}{\partial \beta_1} = -s_1 \beta_1 v_{1}^{-\beta_1} \ln(v_1) + s_1 v_1^{-\beta_1} + s_1 v_1^{-\beta_1}\ln(v_1)$$
$$\frac{\partial u}{\partial \beta_1} = s_1 v_1^{-\beta_1} (1 + \ln(v_1) - \beta_1 \ln(v_1))$$

$$\frac{\partial}{\partial \beta_1} = -\sum \frac{s_1 v_1^{-\beta_1} (1 + \ln(v_1) - \beta_1 \ln(v_1))}{u}$$
Similarly for $\beta_2$
$$\frac{\partial}{\partial \beta_2} = -\sum \frac{s_2 v_2^{-\beta_2} (1 + \ln(v_2) - \beta_2 \ln(v_2))}{u}$$


```{r}
myenv <- new.env()
assign("lambda1", 0.5, envir = myenv)
assign("beta1", 2, envir = myenv)
assign("alpha1", 1, envir = myenv)
assign("x1", 40, envir = myenv)
assign("y1", 20, envir = myenv)
assign("lambda2", 0.5, envir = myenv)
assign("beta2", 1.8, envir = myenv)
assign("alpha2", 1.2, envir = myenv)
assign("x2", 30, envir = myenv)
assign("y2", 30, envir = myenv)
assign("x", 35, envir = myenv)
assign("y", 25, envir = myenv)

f <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
  #common terms
  c1 <- (beta1 - 1)/(pi*alpha1^2)
  c2 <- (beta2 - 1)/(pi*alpha2^2)
  v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
  v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
  
  predDensity <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
  return(-sum(log(predDensity)))
}

f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)

outputnumderiv <- numericDeriv(quote(f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)), c("lambda1", "x1", "y1", "alpha1", "beta1", "lambda2", "x2", "y2", "alpha2", "beta2"), myenv)
```
```{r}
derivf <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
  #common terms
  c1 <- (beta1 - 1)/(pi*alpha1^2)
  c2 <- (beta2 - 1)/(pi*alpha2^2)
  v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
  v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
  
  s1 <- lambda1/(pi*alpha1^2)
  s2 <- lambda2/(pi*alpha2^2)
  
  u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
  
  #partial derivatives
  dLambda1 <- -sum(c1/(u*v1^beta1))
  dLambda2 <- -sum(c2/(u*v2^beta2))
  
  dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
  dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
  dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
  dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
  
  # dAlpha1 <- -sum((2*lambda1*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
  # dAlpha2 <- -sum((2*lambda2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
  
  dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
  dAlpha2 <- -sum(((2*lambda2*(beta2 - 1)/(pi*alpha2^3*v2^beta2))*((beta2*((x-x2)^2 + (y-y2)^2)/(v2*alpha2^2))-1))/u)
  
  dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
  dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
  
  
  return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}

outputderivf <- derivf(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
```
```{r}
outputnumderiv
outputderivf
```

```{r}
derivNLLMM2MOFFAT <- function(params, x, y){
  #component density 1
  lambda1 <- params[[1]]
  x1 <- params[[2]]
  y1 <- params[[3]]
  alpha1 <- params[[4]]
  beta1 <- params[[5]]
  #component density 2
  # lambda2 <- params[[6]]
  x2 <- params[[6]]
  y2 <- params[[7]]
  alpha2 <- params[[8]]
  beta2 <- params[[9]]
  
  lambda2 <-  1 - lambda1
  
  #common terms
  c1 <- (beta1 - 1)/(pi*alpha1^2)
  c2 <- (beta2 - 1)/(pi*alpha2^2)
  v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
  v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
  
  s1 <- lambda1/(pi*alpha1^2)
  s2 <- lambda2/(pi*alpha2^2)
  
  u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
  
  #partial derivatives
  dLambda1 <- -sum(c1/(u*v1^beta1))
  # dLambda2 <- -sum(c2/(u*v2^beta2))
  
  dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
  dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
  dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
  dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
  
  
  # dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
  # dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
  # dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
  # dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
  
  dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
  dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
  
  dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
  dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
  
  # dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
  # dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
  
  return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dx2, dy2, dAlpha2, dBeta2))
}
```




```{r}
set.seed(111)
data1 <- cbind(rnorm(300, mean = 0, sd = 0.4), rnorm(300, mean = 0, sd = 0.4))
data2 <- cbind(rnorm(300, mean = 5, sd = 0.4), rnorm(300, mean = 5, sd = 0.4))

datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
plot(datafull)

initParams = c(x0 = 0, y0 = 0, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result <- optim(par = initParams, fn = NLL2D, gr = deriv2DNLL, x = data1[,1], y = data1[,2], method = "L-BFGS-B", lower = lowerBounds)
opt <- result$par

initParams2 = c(x0 = 5, y0 = 5, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result2 <- optim(par = initParams2, fn = NLL2D, gr = deriv2DNLL, x = data2[,1], y = data2[,2], method = "L-BFGS-B", lower = lowerBounds)
opt2 <- result2$par
```

```{r}
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha1 = opt[[3]], beta1 = opt[[4]], x2 = opt2[[1]], y2 = opt2[[2]], alpha2 = opt2[[3]], beta2 = opt2[[3]])

# initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)

lowerbounds = c(1e-6, -100, -100, 1e-6, 1+1e-6, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 100, 100, Inf, Inf)


MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult

opt
opt2
out <- MMresult$par
out
```
```{r}
xRange <- seq(-20, 20, length = 100)
yRange <- seq(-20, 20, length = 100)
grid <- expand.grid(x = xRange, y = yRange)

oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")

contours <- ggplot(grid, aes(x = x, y = y)) + 
  stat_contour(aes(z = zMM), bins = 10) +
  coord_fixed()
```

```{r}
dataFull <- as.data.frame(datafull)
colnames(dataFull) = c("x", "y")

randomModel <- ggplot(dataFull, aes(x = x, y = y)) +
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(2, 4, 8, 16)) +
  coord_fixed()

randomModel2 <- ggplot(dataFull, aes(x = x, y = y)) +
   geom_point(size = 0.2)


randomModel
contours

randomModel2

```

```{r}
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- randomModel2 + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5) + coord_fixed()
MMcombined
```

#On the Data
```{r}
initialParams <- c(lambda1 = 0.7, x1 = 4115.261, y1 = 4051.904, alpha1 = 0.683, beta1 = 1.9, x2 = 4124, y2 = 4063, alpha2 = 0.5, beta2 = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)

MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea$x, y = interestArea$y, method = "L-BFGS-B", upper = upperbounds, lower = lowerbounds)

MMresult
out <- MMresult$par
```

```{r}
xRange <- seq(4110, 4130, length = 100)
yRange <- seq(4045, 4065, length = 100)
grid <- expand.grid(x = xRange, y = yRange)

oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")

contours <- ggplot(grid, aes(x = x, y = y)) + 
  stat_contour(aes(z = zMM), bins = 10) +
  coord_fixed()

contours
```
```{r}
interestAreaModel <- ggplot(interestArea, aes(x = x, y = y)) +
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) +
  coord_fixed()

interestAreaModel
```
```{r}
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestAreaModel + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcombined
```

Interest Area 2 - 2 celestial sources
```{r}
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S2$x), y1 = mean(interestArea2S2$y), alpha1 = 0.5, beta1 = 1.9, x2 = mean(interestArea2S1$x), y2 = mean(interestArea2S1$y), alpha2 = 0.5, beta2 = 1.9)
lowerbounds = c(0, 3900, 3900, 1e-6, 1+1e-6, 3900, 3900, 1e-6, 1+1e-6)
upperbounds = c(1, 4400, 4400, Inf, Inf, 4400, 4400, Inf, Inf)

MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)

MMresult
out <- MMresult$par
```
```{r}
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4160, 4190, length = 100)
grid <- expand.grid(x = xRange, y = yRange)

oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")

contours <- ggplot(grid, aes(x = x, y = y)) + 
  stat_contour(aes(z = zMM), bins = 10) +
  coord_fixed()

contours
```
```{r}
interestArea2Model <- ggplot(interestArea2, aes(x = x, y = y)) +
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) +
  coord_fixed()

interestArea2Model

interestArea2Model2 <- ggplot(interestArea2, aes(x = x, y = y)) +
  geom_point(size = 0.5, shape = "1") +
  coord_fixed()

interestArea2Model2
```
```{r}
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestArea2Model + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcombined
```