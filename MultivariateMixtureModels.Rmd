---
title: "Multivariate Mixture Models"
output: html_document
date: "2024-04-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Importing the Data
```{r}
library(here)
i_am("MultivariateMixtureModels.Rmd")
# laptop data from csv
Terzan5 <- readr::read_csv(here("Data", "Terzan 5 X-ray events.csv"), col_types = list(.default = readr::col_guess()), )
# head(Terzan5)

#fishbowl data from ODS
# library(readODS)
# Terzan5 <- read_ods(here("Raw Data.ods"), col_types = list(.default = readr::col_guess()), )
#removing extraneous columns
T5 <- data.frame(Terzan5$x, Terzan5$y)
colnames(T5) <- c('x','y')

library(ggplot2)
library(ggpointdensity)
library(viridis)

# ggplot(T5,aes(x,y)) + 
#   geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") + 
#   scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(10, 100, 1000, 10000)) + 
#   coord_fixed()
```
Filtering down to area of interest
```{r}
library(tidyr)
library(plotly)
interestArea <- T5 %>%
  filter(x>4100 & x<4150 & y>4025 & y<4075)

ggplot(interestArea,aes(x,y)) + 
  geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") + 
  scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) + 
  coord_fixed()
```
```{r}
ggplot(interestArea,aes(x,y)) +
  geom_point(size = 0.5)
```


There is three clearly evident celestial sources in this area.
There are two small areas that could also be celestial sources (located above and below the highest definitive source).

I will be attempting to fit a multivariate mixture model for the entire area. The model will contain three(?) individual 2D Moffat distributions.

The lowest and densest source has already been modelled individually and is denoted as POI2 in previous Rmarkdown files. 

```{r}
library(mixtools)

set.seed(111)
data1 <- cbind(rnorm(100, mean = 0, sd = 1), rnorm(100, mean = 0, sd = 1))
data2 <- cbind(rnorm(100, mean = 5, sd = 1), rnorm(100, mean = 5, sd = 1))

datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
plot(datafull)

fit <- mvnormalmixEM(datafull, k = 2)

names(fit)

fit$lambda
fit$mu
fit$sigma

fit$loglik
#fit$posterior
fit$all.loglik
fit$restarts

plot.mixEM(fit, whichplots = 2)
plot.mixEM(fit, whichplots = 1)
```
From the results 

lambda returns the weightings of each cluster

The mean location of the first cluster (red) is (-0.012, -0.016) 
The mean location of the second cluster (green) is (5.14, 5.02)

Sigma returns the covariance matrixes

```{r}
trial <- mvnormalmixEM(interestArea, k = 3)
```

```{r}
par(pty = "s")
plot.mixEM(trial, whichplots = 2)
```

```{r}
plot.mixEM(trial, whichplots = 1)
trial$lambda
trial$mu
trial$sigma
```
- returns values of (4115.262, 4051.881), for the celestial source that has already been examined.
Individually this returned (4115.261, 4051.904)
```{r}
library(mixAK)
NMixEM(datafull, K = 2)
```
This returns the same values as the mixtools packages - however it displays it in a much neater way.


Mean Vector and Covariance Matrix
```{r}
set.seed(222)
randomMatrix <- matrix(rnorm(10), nrow = 5)
randomMatrix

colMeans(randomMatrix)
cov(randomMatrix)
```
```{r}
#generate random cluster 2
set.seed(224)
randomMatrix2 <- matrix(rnorm(500, mean = 3, sd = 0.4), nrow = 250)
mean2 <- colMeans(randomMatrix2)
covmat2 <- cov(randomMatrix2)
det2 <- det(covmat2)

#generate random cluster 3
set.seed(225)
randomMatrix3 <- matrix(rnorm(500, mean = 1, sd = 0.2), nrow = 250)
mean3 <- colMeans(randomMatrix3)
covmat3 <- cov(randomMatrix3)
det3 <- det(covmat3)

#asign a random point somewhere in the region
z <- matrix(c(3, 3.2), nrow = 1)
```

```{r}
plot(randomMatrix2[,1], randomMatrix2[,2], xlim = c(-2, 5), ylim = c(-2, 5))#random cluster 2
points(randomMatrix3[,1], randomMatrix3[,2], col = "red")#random cluster 3
```

```{r}
randomClusters <- rbind(randomMatrix2, randomMatrix3)
fit1 <- mvnormalmixEM(randomClusters, k = 2)
fit1
plot.mixEM(fit1, whichplots = 2)
points(z[,1], z[,2], col = "blue") #random point - what's the density of this point if it exists in either cluster?
fit2 <- NMixEM(randomClusters, K= 2)
fit2
```
The parameters have been estimated using a spatial mixture model - I want to know associated density of a random point z. where z is (2,1)
```{r}
#Using the estimated parameters
c1 <- exp(-0.5*(z-fit1$mu[[1]]) %*% solve(fit1$sigma[[1]]) %*% t(z-fit1$mu[[1]]))/(2*pi*sqrt(det(fit1$sigma[[1]])))
c2 <- exp(-0.5*(z-fit1$mu[[2]]) %*% solve(fit1$sigma[[2]]) %*% t(z-fit1$mu[[2]]))/(2*pi*sqrt(det(fit1$sigma[[2]])))
c1
c2
fit1$lambda[[1]]*c1+fit1$lambda[[2]]*c2
```

```{r}
#Using the known data
p1 <- (1/(2*pi*sqrt(det2)))*exp(-0.5*(z-mean2) %*% solve(covmat2) %*% t(z-mean2)) #component density if existing in cluster 2
p2 <- (1/(2*pi*sqrt(det3)))*exp(-0.5*(z-mean3) %*% solve(covmat3) %*% t(z-mean3)) #component density if existing in cluster 3
pz <- 0.5*p1 + 0.5*p2 #component density of existing in either cluster
p1
p2
pz
```


Creating a mixture model that uses two 2D moffat functions. 
$$ f(y_j) = \sum^{2}_{i=1} \lambda_i f_i(y_j)$$
Where $\lambda_i$ is the mixing proportion parameter and $f_i(y_j)$ are the component densities. Which in the case of a moffat density looks like this.
$$f_i(y_j) = \frac{\beta_i-1}{\pi\alpha_i^2}\left[1 + \frac{(x_j-\bar{x}_{i})^2 + (y_j - \bar{y}_{i})^2}{\alpha_i^2}\right]^{-\beta_i} $$
The mixture model in full:
$$ f(y_j) = \lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}$$

```{r}
MM2MOFFAT <- function(params, x, y){
  #component density 1
  lambda1 <- params[[1]]
  x1 <- params[[2]]
  y1 <- params[[3]]
  alpha1 <- params[[4]]
  beta1 <- params[[5]]
  #component density 2
  lambda2 <- params[[6]]
  x2 <- params[[7]]
  y2 <- params[[8]]
  alpha2 <- params[[9]]
  beta2 <- params[[10]]
  
  #restrictions
  alpha1 <- pmax(alpha1, 1e-6)
  beta1 <- pmax(beta1, 1 + 1e-6)
  alpha2 <- pmax(alpha2, 1e-6)
  beta2 <- pmax(beta2, 1 + 1e-6)
  
  lambda1 <- pmin(lambda1, 1)
  lambda1 <- pmax(lambda1, 1 - lambda2)
  lambda2 <- pmin(lambda2, 0 + lambda1)
  lambda2 <- pmax(lambda2, 1 - lambda1)
  
  return(((lambda1*(beta1 - 1)/(pi*alpha1^2))*(1+((x-x1)^2+(y-y1)^2)/(alpha1^2))^(-beta1)) + 
  ((lambda2*(beta2 - 1)/(pi*alpha2^2))*(1+((x-x2)^2+(y-y2)^2)/(alpha2^2))^(-beta2)))
}

library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, lambda2 = 0.5, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, lambda2 = 0.3, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, lambda2 = 0.45, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
```
When integrating the function over the entire range it should equate to 1 - this is tricky to evaluate due to how R handles integration.

```{r}
MM2MOFFATimage <- function(params, grid){
  x <- grid[[1]]
  y <- grid[[2]]
  
  #component density 1
  lambda1 <- params[[1]]
  x1 <- params[[2]]
  y1 <- params[[3]]
  alpha1 <- params[[4]]
  beta1 <- params[[5]]
  #component density 2
  lambda2 <- params[[6]]
  x2 <- params[[7]]
  y2 <- params[[8]]
  alpha2 <- params[[9]]
  beta2 <- params[[10]]
  
  #restrictions
  alpha1 <- pmax(alpha1, 1e-6)
  beta1 <- pmax(beta1, 1 + 1e-6)
  alpha2 <- pmax(alpha2, 1e-6)
  beta2 <- pmax(beta2, 1 + 1e-6)
  
  lambda1 <- pmin(lambda1, 1)
  lambda1 <- pmax(lambda1, 0)
  lambda2 <- pmin(lambda2, 1)
  lambda2 <- pmax(lambda2, 1-lambda1)
  
  return(((lambda1*(beta1 - 1)/(pi*alpha1^2))*(1+((x-x1)^2+(y-y1)^2)/(alpha1^2))^(-beta1)) + 
  ((lambda2*(beta2 - 1)/(pi*alpha2^2))*(1+((x-x2)^2+(y-y2)^2)/(alpha2^2))^(-beta2)))
}

xRange <- seq(-20, 20, length = 200)
yRange <- seq(-20, 20, length = 200)
grid <- expand.grid(xRange, yRange)

testParams3 <- c(lambda1 = 0.55, x1 = -5, y1 = -4, alpha1 = 1.2, beta1 = 2, lambda2 = 0.45, x2 = 10, y2 = 2, alpha2 = 1.2, beta2 = 2)


z3 <- MM2MOFFATimage(params = testParams3, grid)
z3Matrix <- matrix(z3, nrow = length(xRange), ncol = length(yRange))
image(xRange, yRange, z3Matrix)
```

The Negative Log-Likelihood of the Mixture Model containing 2 Moffat component densities.
$$-\sum^{n}_{j=1}\ln\left[\lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}\right]$$

```{r}
NLLMM2MOFFAT <- function(params, x, y){
  predictedDens <- MM2MOFFAT(params, x, y)
  return(-sum(log(predictedDens)))
}
```

To find the partial derivatives of the Negative Log Likelihood
Let $ u = \lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2} $


First, the the partial derivative with respect to $\bar{x}_1$.
$$-\sum^{n}_{j=1}\ln{u}$$
Let $ v_i = 1 + \frac{(x_j-\bar{x}_{i})^2 + (y_j - \bar{y}_{i})^2}{\alpha_i^2} $

Let $ c_i = \frac{(\beta_i-1)}{\pi\alpha_{i}^{2}} $

$$ u = \lambda_1 c_1 v_1^{-\beta_1} + \lambda_2 c_2 v_2^{-\beta_2} $$

For $\frac{\delta}{\delta x_1}$
$$\frac{\delta}{\delta x_1} = \frac{\delta}{\delta u} \frac{\delta u}{\delta v_1} \frac{\delta v_1}{\delta x_1}$$
$$\frac{\delta}{\delta u} = -\sum\frac{1}{u}$$
$$\frac{\delta u}{\delta v_1} = - \lambda_1 c_1 \beta_1 v_{1}^{-(\beta_1 + 1)}$$
$$\frac{\delta v_1}{\delta x_1} = \frac{-2(x_j - \bar{x}_1)}{\alpha_{1}^{2}}$$
$$\frac{\delta}{\delta x_1} = -\sum\frac{1}{u} (-\lambda_1 c_1 \beta_1 v_{1}^{-(\beta_1 + 1)})(\frac{-2(x_j - \bar{x}_1)}{\alpha_{1}^{2}})$$
In full
$$\frac{\delta}{\delta x_1} = -\sum\frac{(\frac{\lambda_1(\beta_1-1)}{\pi\alpha_{1}^{2}} \beta_1 \left[1 + \frac{(x_j-\bar{x}_{i})^2 + (y_j - \bar{y}_{i})^2}{\alpha_i^2}\right]^{-(\beta_1 + 1)})(\frac{2(x_j - \bar{x}_1)}{\alpha_{1}^{2}})}
{\lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}}$$

A similar method is used to find the partial derivative with respect to $\bar{x}_2$, $\bar{y}_1$ and $\bar{y}_2$.

$$\frac{\delta}{\delta x_2} = -\sum\frac{1}{u} (-\lambda_2 c_2 \beta_2 v_{2}^{-(\beta_2 + 1)})(\frac{-2(x_j - \bar{x}_2)}{\alpha_{2}^{2}})$$
$$\frac{\delta}{\delta x_1} = -\sum\frac{1}{u} (-\lambda_1 c_1 \beta_1 v_{1}^{-(\beta_1 + 1)})(\frac{-2(y_j - \bar{y}_1)}{\alpha_{1}^{2}})$$

$$\frac{\delta}{\delta x_2} = -\sum\frac{1}{u} (-\lambda_2 c_2 \beta_2 v_{2}^{-(\beta_2 + 1)})(\frac{-2(y_j - \bar{y}_2)}{\alpha_{2}^{2}})$$
For the partial derivative with respect to $\lambda_1$
$$\frac{\delta u}{\delta \lambda_1} = c_1  v_{1}^{-\beta_1}$$
$$\frac{\delta}{\delta \lambda_1} = -\sum\frac{c_1 v_{1}^{-\beta_1}}{u}$$
Similarly for $\lambda_2$
$$\frac{\delta}{\delta \lambda_2} = -\sum\frac{c_2 v_{2}^{-\beta_2}}{u}$$

For the partial derivative with respect to $\alpha_1$, the product rule is applied
Let $w = \frac{\lambda_1(\beta_1 -1)}{\pi}\alpha_{1}^{-2}$
Let $d = v_1^{-\beta_1}$
So $u = wd$
$\frac{\delta u}{\delta \alpha_1} = wd' + w'd$

$w' = -2\frac{\lambda_1(\beta_1 - 1)}{\pi}\alpha_{1}^{-3}$
To find d' the quotient and chain rules are applied
$d' = \frac{2\beta_1\left[(x-x_1)^{2}+(y-y_1)^{2}\right]}{\left[1+\frac{(x-x_1)^2 + (y-y_1))^2}{\alpha_{1}^{2}}\right]^{-(\beta + 1)}\alpha_{1}^{3}}$

$$\frac{\delta u}{\delta \alpha_1} = \frac{\lambda_1(\beta_1 -1)}{\pi\alpha_{1}^{2}} \frac{2\beta_1\left[(x-x_1)^{2}+(y-y_1)^{2}\right]}{\left[1+\frac{(x-x_1)^2 + (y-y_1))^2}{\alpha_{1}^{2}}\right]^{-(\beta + 1)}\alpha_{1}^{3}} - 2\frac{\lambda_1(\beta_1 - 1)}{\pi\alpha_{1}^{3}} (1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2})^{-\beta_1}$$
$$\frac{\delta}{\delta \alpha_1} = -\sum \frac{\frac{2\lambda_1(\beta_1 - 1)}{\pi\alpha_{1}^{2}}\left[\frac{\beta_1\left[(x-x_1)^{2}+(y-y_1)^{2}\right]}{\left[1+\frac{(x-x_1)^2 + (y-y_1))^2}{\alpha_{1}^{2}}\right]^{-(\beta + 1)}\alpha_{1}^{3}} - \frac{1}{\alpha_1}(1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2})^{-\beta_1}\right]}{\lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}}$$
Similarly for $\alpha_2$
$$\frac{\delta}{\delta \alpha_2} = -\sum \frac{\frac{2\lambda_2(\beta_2 - 1)}{\pi\alpha_{2}^{2}}\left[\frac{\beta_2\left[(x-\bar{x}_2)^{2}+(y-\bar{y}_2)^{2}\right]}{\left[1+\frac{(x-\bar{x}_2)^2 + (y-\bar{y}_2))^2}{\alpha_{2}^{2}}\right]^{-(\beta_2 + 1)}\alpha_{2}^{3}} - \frac{1}{\alpha_2}(1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2})^{-\beta_2}\right]}{\lambda_1\frac{\beta_1-1}{\pi\alpha_1^2}\left[1 + \frac{(x_j-\bar{x}_{1})^2 + (y_j - \bar{y}_{1})^2}{\alpha_1^2}\right]^{-\beta_1} + \lambda_2\frac{\beta_2-1}{\pi\alpha_2^2}\left[1 + \frac{(x_j-\bar{x}_{2})^2 + (y_j - \bar{y}_{2})^2}{\alpha_2^2}\right]^{-\beta_2}}$$

For the partial derivative with respect to $\beta_1$.
Let $s_1 = \frac{\lambda_1}{\pi\alpha_{1}^{2}}$
$u = s\beta_1 v_{1}^{-\beta_1} - sv_{1}^{-\beta_1}$

$$\frac{\delta u}{\delta \beta_1} = s_1 v_{1}^{-\beta_1}(1-\beta_1\ln(v_1) + \ln(v_1))$$
$$\frac{\delta}{\delta \beta_1} = -\sum \frac{ sv_{1}^{-\beta_1}(1-\beta_1\ln(v_1) + \ln(v_1))}
{u}$$
Similarly for $\beta_2$
$$\frac{\delta u}{\delta \beta_2} = s_2 v_{2}^{-\beta_2}(1-\beta_2\ln(v_2) + \ln(v_2))$$

```{r}
derivNLLMM2MOFFAT <- function(params, x, y){
  #component density 1
  lambda1 <- params[[1]]
  x1 <- params[[2]]
  y1 <- params[[3]]
  alpha1 <- params[[4]]
  beta1 <- params[[5]]
  #component density 2
  lambda2 <- params[[6]]
  x2 <- params[[7]]
  y2 <- params[[8]]
  alpha2 <- params[[9]]
  beta2 <- params[[10]]
  
  #common terms
  v1 <- (1+(((x-x1)^2+(y-y1)^2)/(alpha1^2)))
  v2 <- (1+(((x-x2)^2+(y-y2)^2)/(alpha2^2)))
  c1 <- ((beta1 - 1)/(pi*alpha1^2))
  c2 <- ((beta2 - 1)/(pi*alpha2^2))
  s1 <- lambda1/(pi*alpha1^2)
  s2 <- lambda2/(pi*alpha2^2)
  
  u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
  
  #partial derivatives
  dLambda1 <- -sum((c1*v1^(-beta1))/u)
  dLambda2 <- -sum((c2*v2^(-beta2))/u)
  
  dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
  dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
  dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
  dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
  
  dAlpha1 <- -sum((2*lambda1*c1)*((beta1*((x-x1)^2+(y-y1)^2)/((alpha1^3)*(v1^(-beta1-1)))) - ((v1^-beta1)/alpha1))/u)
  dAlpha2 <- -sum((2*lambda2*c2)*((beta2*((x-x2)^2+(y-y2)^2)/((alpha2^3)*(v2^(-beta2-1)))) - ((v2^-beta2)/alpha2))/u)
  
  dBeta1 <- -sum(((s1*v1^(-beta1))*(1-beta1*log(v1)+log(v1)))/u)
  dBeta2 <- -sum(((s2*v2^(-beta2))*(1-beta2*log(v2)+log(v2)))/u)
  
  return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
```

```{r}
set.seed(111)
data1 <- cbind(rnorm(100, mean = 0, sd = 1), rnorm(100, mean = 0, sd = 1))
data2 <- cbind(rnorm(100, mean = 5, sd = 1), rnorm(100, mean = 5, sd = 1))

datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
plot(datafull)

initParams = c(x0 = 0, y0 = 0, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result <- optim(par = initParams, fn = NLL2D, gr = deriv2DNLL, x = data1[,1], y = data1[,2], method = "L-BFGS-B", lower = lowerBounds)
opt <- result$par

initParams2 = c(x0 = 5, y0 = 5, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result2 <- optim(par = initParams2, fn = NLL2D, gr = deriv2DNLL, x = data2[,1], y = data2[,2], method = "L-BFGS-B", lower = lowerBounds)
opt2 <- result2$par
```

```{r}
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)


MMresult <- optimx(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult

opt
opt2
MMresult$par
```

```{r}
library(optimx)
initialParams <- c(lambda1 = 0.7, x1 = 4115.261, y1 = 4051.904, alpha = 0.683, beta = 1.9, lambda2 = 0.3, x2 = 4124, y2 = 4063, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)

MMresult <- optimx(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea$x, y = interestArea$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)

MMresult$par
```

