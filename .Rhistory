beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 0)
lambda2 = 1 - lambda1
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}
library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
initialParams <- c(lambda1 = 0.5, x1 = 4115, y1 = 4182, alpha = 0.7, beta = 1.9, x2 = 4128, y2 = 4178, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
NLLMM2MOFFAT <- function(params, x, y){
predictedDens <- MM2MOFFAT(params, x, y)
return(-sum(log(predictedDens)))
}
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
# lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
lambda2 = 1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
# dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dx2, dy2, dAlpha2, dBeta2))
}
initialParams <- c(lambda1 = 0.5, x1 = 4115, y1 = 4182, alpha = 0.7, beta = 1.9, x2 = 4128, y2 = 4178, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4060, 4090, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")
contours <- ggplot(grid, aes(x = x, y = y)) +
stat_contour(aes(z = zMM), bins = 10) +
coord_fixed()
contours
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4160, 4190, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")
contours <- ggplot(grid, aes(x = x, y = y)) +
stat_contour(aes(z = zMM), bins = 10) +
coord_fixed()
contours
interestArea2Model <- ggplot(interestArea2, aes(x = x, y = y)) +
geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) +
coord_fixed()
interestArea2Model
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestAreaModel + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestArea2Model + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcombined
interestArea2S1 <- interestArea2 %>%
filter(x>4110 & x<4120 & y>4177 & y<4187)
interestArea2S2 <- interestArea2 %>%
filter(x>4124 & x<4134 & y>4173 & y<4183)
length(interestArea2S1)
length(interestArea2S2)
interestArea2S1 <- interestArea2 %>%
filter(x>4110 & x<4120 & y>4177 & y<4187)
interestArea2S2 <- interestArea2 %>%
filter(x>4124 & x<4134 & y>4173 & y<4183)
nrow(interestArea2S1)
nrow(interestArea2S2)
initialParams <- c(lambda1 = 0.5, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4160, 4190, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")
contours <- ggplot(grid, aes(x = x, y = y)) +
stat_contour(aes(z = zMM), bins = 10) +
coord_fixed()
contours
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestArea2Model + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcombined
initialParams <- c(lambda1 = 0.3, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
initialParams <- c(lambda1 = 0.5, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
initialParams <- c(lambda1 = 0.7, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
initialParams <- c(lambda1 = 0.5, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
initialParams <- c(lambda1 = 0.5, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 4000, 4000, Inf, Inf, 4000, 4000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
initialParams <- c(lambda1 = 0.5, x1 = 4128, y1 = 4178, alpha = 0.7, beta = 1.9, x2 = 4115, y2 = 4182, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4160, 4190, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")
contours <- ggplot(grid, aes(x = x, y = y)) +
stat_contour(aes(z = zMM), bins = 10) +
coord_fixed()
contours
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestArea2Model + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcombined
initialParams <- c(lambda1 = 0.5, x1 = 4120, y1 = 4175, alpha = 0.7, beta = 1.9, x2 = 4120, y2 = 4175, alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4160, 4190, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")
contours <- ggplot(grid, aes(x = x, y = y)) +
stat_contour(aes(z = zMM), bins = 10) +
coord_fixed()
contours
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
xRange <- seq(4105, 4135, length = 100)
yRange <- seq(4160, 4190, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
oparams <- c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], 1-out[[1]], out[[6]], out[[7]], out[[8]], out[[9]])
zMM <- MM2MOFFATimage(grid, params = oparams)
zmat <- matrix(zMM, nrow = length(xRange), ncol = length(yRange))
par(pty = "s")
image(xRange, yRange, zmat, xlab = "x", ylab = "y", main = "2D Moffat")
contours <- ggplot(grid, aes(x = x, y = y)) +
stat_contour(aes(z = zMM), bins = 10) +
coord_fixed()
contours
MMcontourData <- ggplot_build(contours)$data[[1]] #extracting the contours (from the optimised function)
MMcombined <- interestArea2Model + geom_path(data = MMcontourData, aes(x = x, y = y, group = group), color = "red", alpha = 0.5)
MMcombined
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
# lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
lambda2 <-  1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
#restrictions
alpha1 <- pmax(alpha1, 1e-6)
beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 0)
lambda2 = 1 - lambda1
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}
library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
lambda2 <-  1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, lambda2 = 0.5, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 0, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 1, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
MM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
#lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
#restrictions
alpha1 <- pmax(alpha1, 1e-6)
beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 0)
lambda2 = 1 - lambda1
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}
library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
# lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
lambda2 <-  1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
# lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
lambda2 <-  1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
# dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dx2, dy2, dAlpha2, dBeta2))
}
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 4000, 4000, 1e-6, 1+1e-6, 4000, 4000, 1e-6, 1+1e-6)
upperbounds = c(1, 4500, 4500, Inf, Inf, 4500, 4500, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S1$x), y1 = mean(interestArea2S1$y), alpha = 0.7, beta = 1.9, x2 = mean(interestArea2S2$x), y2 = mean(interestArea2S2$y), alpha = 0.5, beta = 1.9)
lowerbounds = c(0, 3900, 3900, 1e-6, 1+1e-6, 3900, 3900, 1e-6, 1+1e-6)
upperbounds = c(1, 4400, 4400, Inf, Inf, 4400, 4400, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea2$x, y = interestArea2$y, method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
out <- MMresult$par
