log(0.5*sqrt(pi)*(2*10 - 1) - 1)
yseq <- seq(1e-6,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+2/sqrt(pi)*(-exp(-x/sqrt(2))+1)))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(0.5*sqrt(pi)*(2*y - 1) - 1)
}
log(0.5*sqrt(pi)*(2*1 - 1) - 1)
yseq <- seq(1e-6,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+2/sqrt(pi)*(-exp(-x/sqrt(2))+1)))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(0.5*sqrt(pi)*(2*y - 1) - 1)
}
(0.5*sqrt(pi)*(2*1 - 1) - 1)
yseq <- seq(1e-6,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+2/sqrt(pi)*(-exp(-x/sqrt(2))+1)))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(-0.5*sqrt(pi)*(2*y - 1) - 1)
}
(0.5*sqrt(pi)*(2*1 - 1) - 1)
yseq <- seq(1e-6,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+2/sqrt(pi)*(-exp(-x/sqrt(2))+1)))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(-(0.5*sqrt(pi)*(2*y - 1) - 1))
}
(0.5*sqrt(pi)*(2*1 - 1) - 1)
yseq <- seq(1e-6,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+2/sqrt(pi)*(-exp(-x/sqrt(2))+1)))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(-(0.5*sqrt(pi)*(2*y - 1) - 1))
}
(0.5*sqrt(pi)*(2*1 - 1) - 1)
yseq <- seq(0,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+(2/sqrt(pi)*(-exp(-x/sqrt(2))+1))))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(-(0.5*sqrt(pi)*(2*y - 1) - 1))
}
yseq <- seq(0,1, length = 20)
iCDF(yseq)
CDF <- function(x){
return(0.5*(1+((2*(-exp(-x/sqrt(2))+1))/sqrt(pi))))
}
xseq <- seq(-3,3, length = 20)
CDF(xseq)
iCDF <- function(y){
sqrt(2)*log(-(0.5*sqrt(pi)*(2*y - 1) - 1))
}
yseq <- seq(0,1, length = 20)
iCDF(yseq)
iCDF <- function(y){
qnorm(p = y, mean = 0, sd = 1)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq)
iCDF <- function(y){
qnorm(p = y, mean = 0, sd = 1)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq)
y <- runif(20, min = 0, max = 1)
iCDF(y)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
qmoffat(p = y, params)
}
params <- c(0,0,1,2)
iCDFMOFFAT <- function(y, params)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
qmoffat(p = y, params)
}
params <- c(0,0,1,2)
iCDFMOFFAT(y, params)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
Vqmoffat(p = y, params)
}
params <- c(0,0,1,2)
iCDFMOFFAT(y, params)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
qmoffat(p = y, params)
return(Vectorize(qmoffat, vectorize.args = "p"))
}
params <- c(0,0,1,2)
iCDFMOFFAT(y, params)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
qmoffat(p = y, params)
return(Vectorize(qmoffat, vectorize.args = "p"))
}
params <- c(0,0,1,2)
#iCDFMOFFAT(y, params)
qmoffat(0.5, params)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
qmoffat(p = y, params)
return(Vectorize(qmoffat, vectorize.args = "p"))
}
params <- c(0,0,1,2)
#iCDFMOFFAT(y, params)
Vqmoffat(0.5, params)
knitr::opts_chunk$set(echo = TRUE)
# Define the inverse cumulative distribution function (quantile function) for Moffat distribution
qmoffat <- function(p, params) {
# Define a function to find the root (quantile) of CDF - p, this equates to 0.
findRoot <- function(x) {
integrate(MOFFATPDF, lower = -Inf, upper = x, parameters = params)$value - p
}
# Find the root (quantile) using uniroot. For a probability, this will look to find a value of x that causes the findRoot function to equate to 0. This value of x is the quantile.
quantile <- uniroot(findRoot, interval = c(4000,4200))$root
return(quantile)
}
probs <- seq(0.01, 0.99, by = 0.01)
qmoffat(0.5, optimPAR2)
Vqmoffat <- Vectorize(qmoffat, vectorize.args = "p")
quantiles <- Vqmoffat(p = probs, params = optimPAR2)
data.frame(probs, quantiles)
iCDF <- function(y, mean, sd){
qnorm(p = y, mean, sd)
}
yseq <- seq(0,1, length = 20)
iCDF(yseq, 0, 1)
y <- runif(20, min = 0, max = 1)
iCDF(y, 0, 1)
iCDFMOFFAT <- function(y, params){
qmoffat(p = y, params)
return(Vectorize(qmoffat, vectorize.args = "p"))
}
params <- c(0,0,1,2)
#iCDFMOFFAT(y, params)
Vqmoffat(0.5, params)
knitr::opts_chunk$set(echo = TRUE)
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v^beta1))
dLambda2 <- -sum(c2/(u*v^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v1^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v1^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
set.seed(111)
data1 <- cbind(rnorm(100, mean = 0, sd = 1), rnorm(100, mean = 0, sd = 1))
data2 <- cbind(rnorm(100, mean = 5, sd = 1), rnorm(100, mean = 5, sd = 1))
datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
plot(datafull)
initParams = c(x0 = 0, y0 = 0, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result <- optim(par = initParams, fn = NLL2D, gr = deriv2DNLL, x = data1[,1], y = data1[,2], method = "L-BFGS-B", lower = lowerBounds)
opt <- result$par
initParams2 = c(x0 = 5, y0 = 5, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result2 <- optim(par = initParams2, fn = NLL2D, gr = deriv2DNLL, x = data2[,1], y = data2[,2], method = "L-BFGS-B", lower = lowerBounds)
opt2 <- result2$par
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
lambda2 = 1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum((2*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
# dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
# dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
MM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
#restrictions
alpha1 <- pmax(alpha1, 1e-6)
beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 0)
lambda2 = 1 - lambda1
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}
library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, lambda2 = 0.5, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, lambda2 = 0.3, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, lambda2 = 0.45, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
NLLMM2MOFFAT <- function(params, x, y){
predictedDens <- MM2MOFFAT(params, x, y)
return(-sum(log(predictedDens)))
}
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optimx(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams2, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
constraint <- function(params){
return(params[1] + params[6] - 1)
}
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams1, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds, constraints = list(ineq = constraint))
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
constraint <- function(params){
return(params[1] + params[6] - 1)
}
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds, constraints = list(ineq = constraint))
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
constraint <- function(params){
return(params[1] + params[6] - 1)
}
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optimx(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds, constraints = list(ineq = constraint))
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
constraint <- function(params){
return(params[1] + params[6] - 1)
}
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optimx(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds, control = list(fnscale = -1), constraints = list(ineq = constraint))
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
constraint <- function(params){
return(params[1] + params[6] - 1)
}
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds, control = list(fnscale = -1), constraints = list(ineq = constraint))
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha = opt[[3]], beta = opt[[4]], lambda2 = 0.5, x2 = opt2[[1]], y2 = opt2[[2]], alpha = opt2[[3]], beta = opt2[[3]])
initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
lowerbounds = c(0, -100, -100, 1e-6, 1+1e-6, 0, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 1, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
MMresult
opt
opt2
MMresult$par
