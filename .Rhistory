assign("y", seq(20, 30, length = 11), envir = myenv)
f <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
predDensity <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
return(-sum(log(predDensity)))
}
f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
numericDeriv(quote(f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)), c("lambda1", "x1", "y1", "alpha1", "beta1", "lambda2", "x2", "y2", "alpha2", "beta2"), myenv)
myenv <- new.env()
assign("lambda1", 0.5, envir = myenv)
assign("beta1", 2, envir = myenv)
assign("alpha1", 1, envir = myenv)
assign("x1", 40, envir = myenv)
assign("y1", 20, envir = myenv)
assign("lambda2", 0.5, envir = myenv)
assign("beta2", 1.8, envir = myenv)
assign("alpha2", 1.2, envir = myenv)
assign("x2", 30, envir = myenv)
assign("y2", 30, envir = myenv)
assign("x", 35, envir = myenv)
assign("y", 25, envir = myenv)
f <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
predDensity <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
return(-sum(log(predDensity)))
}
f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
numericDeriv(quote(f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)), c("lambda1", "x1", "y1", "alpha1", "beta1", "lambda2", "x2", "y2", "alpha2", "beta2"), myenv)
derivf <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
dAlpha1 <- -sum((2*lambda1*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
dAlpha2 <- -sum((2*lambda2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
derivf(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
derivf <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dAlpha1 <- -sum((2*lambda1*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
# dAlpha2 <- -sum((2*lambda2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
derivf(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
derivf <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dAlpha1 <- -sum((2*lambda1*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
# dAlpha2 <- -sum((2*lambda2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dAlpha2 <- -sum(((2*lambda2*(beta2 - 1)/(pi*alpha2^3*v2^beta2))*((beta2*((x-x2)^2 + (y-y2)^2)/(v2*alpha2^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
derivf(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
# lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
lambda2 <-  1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
# dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dx2, dy2, dAlpha2, dBeta2))
}
library(here)
i_am("MultivariateMixtureModels.Rmd")
# laptop data from csv
Terzan5 <- readr::read_csv(here("Data", "Terzan 5 X-ray events.csv"), col_types = list(.default = readr::col_guess()), )
# head(Terzan5)
#fishbowl data from ODS
# library(readODS)
# Terzan5 <- read_ods(here("Raw Data.ods"), col_types = list(.default = readr::col_guess()), )
#removing extraneous columns
T5 <- data.frame(Terzan5$x, Terzan5$y)
colnames(T5) <- c('x','y')
library(ggplot2)
library(ggpointdensity)
library(viridis)
ggplot(T5,aes(x,y)) +
geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(10, 100, 1000, 10000)) +
coord_fixed()
library(tidyr)
library(plotly)
interestArea <- T5 %>%
filter(x>4100 & x<4150 & y>4025 & y<4075)
ggplot(interestArea,aes(x,y)) +
geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) +
coord_fixed()
interestArea2 <- T5 %>%
filter(x>4105 & x<4135 & y>4160 & y<4190)
ggplot(interestArea2,aes(x,y)) +
geom_pointdensity(adjust = 0.05, size = 0.1, shape = "1") +
scale_color_viridis(direction = -1, option = "B", trans = "log", breaks = c(4, 16, 64)) +
coord_fixed()
MM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
#lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
#restrictions
alpha1 <- pmax(alpha1, 1e-6)
beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 0)
lambda2 = 1 - lambda1
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}
library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
MM2MOFFATimage <- function(grid, params){
x <- grid[[1]]
y <- grid[[2]]
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
lambda2 <- params[[6]]
x2 <- params[[7]]
y2 <- params[[8]]
alpha2 <- params[[9]]
beta2 <- params[[10]]
#restrictions
alpha1 <- pmax(alpha1, 1e-6)
beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 1 - lambda2)
lambda2 <- pmin(lambda2, 0 + lambda1)
lambda2 <- pmax(lambda2, 1 - lambda1)
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) +
lambda2*c2*v2^(-beta2))
}
xRange <- seq(-20, 20, length = 200)
yRange <- seq(-20, 20, length = 200)
grid <- expand.grid(xRange, yRange)
testParams3 <- c(lambda1 = 0.55, x1 = -5, y1 = -4, alpha1 = 1.2, beta1 = 2, lambda2 = 0.45, x2 = 10, y2 = 2, alpha2 = 1.2, beta2 = 2)
z3 <- MM2MOFFATimage(params = testParams3, grid)
z3Matrix <- matrix(z3, nrow = length(xRange), ncol = length(yRange))
image(xRange, yRange, z3Matrix)
NLLMM2MOFFAT <- function(params, x, y){
predictedDens <- MM2MOFFAT(params, x, y)
return(-sum(log(predictedDens)))
}
derivNLLMM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
# lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
lambda2 <-  1 - lambda1
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
# dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dx1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((x-x1)/alpha1^2))/u)
# dx2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((x-x2)/alpha2^2))/u)
# dy1 <- -sum(((2*lambda1*c1*beta1*v1^(-beta1-1))*((y-y1)/alpha1^2))/u)
# dy2 <- -sum(((2*lambda2*c2*beta2*v2^(-beta2-1))*((y-y2)/alpha2^2))/u)
dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dAlpha2 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
# dBeta1 <- -sum(((s1*v1^(-beta1)*log(v1))*(1-beta1))/u)
# dBeta2 <- -sum(((s2*v2^(-beta2)*log(v2))*(1-beta2))/u)
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dx2, dy2, dAlpha2, dBeta2))
}
set.seed(111)
data1 <- cbind(rnorm(300, mean = 0, sd = 0.4), rnorm(300, mean = 0, sd = 0.4))
data2 <- cbind(rnorm(300, mean = 5, sd = 0.4), rnorm(300, mean = 5, sd = 0.4))
datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
plot(datafull)
initParams = c(x0 = 0, y0 = 0, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result <- optim(par = initParams, fn = NLL2D, gr = deriv2DNLL, x = data1[,1], y = data1[,2], method = "L-BFGS-B", lower = lowerBounds)
knitr::opts_chunk$set(echo = TRUE)
Moffat2D <- function(grid, parameters){
x <- grid[[1]]
y <- grid[[2]]
amplitude <- parameters[[1]]
x0 <- parameters[[2]]
y0 <- parameters[[3]]
alpha <- parameters[[4]]
beta <- parameters[[5]]
amplitude*(1+((x - x0)^2 + (y - y0)^2)/alpha^2)^(-beta)
}
#grid of variables
xRange <- seq(-5, 5, length = 100)
yRange <- seq(-5, 5, length = 100)
grid <- expand.grid(x = xRange, y = yRange)
#Dummy parameters
dummyParams <- c(amplitude = 1, x0 = 0, y0 = 0, alpha = 1, beta = 1)
z <- Moffat2D(grid, dummyParams)
zMatrix <- matrix(z, nrow = length(xRange), ncol = length(yRange))
image(xRange, yRange, zMatrix, xlab = "x", ylab = "y", main = "2D Moffat")
persp(xRange, yRange, zMatrix, xlab = "x", ylab = "y", zlab = "f(x,y)", main = "2D Moffat")
Moffat2DPDF <- function(parameters, x, y){
x0 <- parameters[[1]]
y0 <- parameters[[2]]
alpha <- parameters[[3]]
beta <- parameters[[4]]
alpha <- pmax(alpha, 1e-6)
beta <- pmax(beta, 1 + 1e-6)
return(((beta-1)/(pi*alpha^2))*(1+((x - x0)^2 + (y - y0)^2)/alpha^2)^(-beta))
}
library(pracma)
#Test 1
T1Params <- c(x0 = 1, y0 = 4, alpha = 0.4, beta = 2)
MoffatIntegral2D1 <- integral2(Moffat2DPDF, xmin = -100, xmax = 100, ymin = -100, ymax = 100, parameters = T1Params)[[1]]
MoffatIntegral2D1
#Test 2
T2Params <- c(x0 = -3, y0 = 7, alpha = 1.2, beta = 1.3)
MoffatIntegral2D2 <- integral2(Moffat2DPDF, xmin = -100, xmax = 100, ymin = -100, ymax = 100, parameters = T2Params)[[1]]
MoffatIntegral2D2
#Test 3
T3Params <- c(x0 = 4, y0 = 0, alpha = 3, beta = 2.4)
MoffatIntegral2D3 <- integral2(Moffat2DPDF, xmin = -100, xmax = 100, ymin = -100, ymax = 100, parameters = T3Params)[[1]]
MoffatIntegral2D3
deriv2DNLL <- function(parameters, x, y){
x0 <- parameters[[1]]
y0 <- parameters[[2]]
alpha <- parameters[[3]]
beta <- parameters[[4]]
dx0 <- -sum((2*beta*(x-x0))/(alpha^2 + (x-x0)^2 + (y-y0)^2))
dy0 <- -sum((2*beta*(y-y0))/(alpha^2 + (x-x0)^2 + (y-y0)^2))
dAlpha <- 2*sum(1/alpha + (beta*((x-x0)^2 + (y-y0)^2))/(alpha^3 + alpha*((x-x0)^2 + (y-y0)^2)))
dBeta <- -sum(1/beta - log(1+((x-x0)^2 + (y-y0)^2)/alpha^2))
return(c(dx0, dy0, dAlpha, dBeta))
}
NLL2D <- function(parameters, x, y){
predictedDens <- Moffat2DPDF(parameters, x, y)
return(-sum(log(predictedDens)))
}
set.seed(111)
data1 <- cbind(rnorm(300, mean = 0, sd = 0.4), rnorm(300, mean = 0, sd = 0.4))
data2 <- cbind(rnorm(300, mean = 5, sd = 0.4), rnorm(300, mean = 5, sd = 0.4))
datafull <- rbind(data1, data2)
plot(data1)
plot(data2)
plot(datafull)
initParams = c(x0 = 0, y0 = 0, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result <- optim(par = initParams, fn = NLL2D, gr = deriv2DNLL, x = data1[,1], y = data1[,2], method = "L-BFGS-B", lower = lowerBounds)
opt <- result$par
initParams2 = c(x0 = 5, y0 = 5, alpha = 1, beta = 1)
lowerBounds = c(0, 0, 1e-6, 1+1e-6)
result2 <- optim(par = initParams2, fn = NLL2D, gr = deriv2DNLL, x = data2[,1], y = data2[,2], method = "L-BFGS-B", lower = lowerBounds)
opt2 <- result2$par
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha1 = opt[[3]], beta1 = opt[[4]], x2 = opt2[[1]], y2 = opt2[[2]], alpha2 = opt2[[3]], beta2 = opt2[[3]])
# initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
lowerbounds = c(1e-6, -100, -100, 1e-6, 1+1e-6, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
NLLMM2MOFFAT <- function(params, x, y){
predictedDens <- MM2MOFFAT(params, x, y)
return(-sum(log(predictedDens)))
}
library(optimx)
initialParams <- c(lambda1 = 0.5, x1 = opt[[1]], y1 = opt[[2]], alpha1 = opt[[3]], beta1 = opt[[4]], x2 = opt2[[1]], y2 = opt2[[2]], alpha2 = opt2[[3]], beta2 = opt2[[3]])
# initialParams2 <- c(lambda1 = 0.5, x1 = 0, y1 = 0, alpha = 1.1, beta = 1.8, lambda2 = 0.5, x2 = 5, y2 = 5, alpha = 1.2, beta = 2)
lowerbounds = c(1e-6, -100, -100, 1e-6, 1+1e-6, -100, -100, 1e-6, 1+1e-6)
upperbounds = c(1, 100, 100, Inf, Inf, 100, 100, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = datafull[,1], y = datafull[,2], method = "L-BFGS-B", lower = lowerbounds, upper = upperbounds)
initialParams <- c(lambda1 = 0.7, x1 = 4115.261, y1 = 4051.904, alpha1 = 0.683, beta1 = 1.9, x2 = 4124, y2 = 4063, alpha2 = 0.5, beta2 = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea$x, y = interestArea$y, method = "L-BFGS-B", upper = upperbounds, lower = lowerbounds)
initialParams <- c(lambda1 = 0.5, x1 = mean(interestArea2S2$x), y1 = mean(interestArea2S2$y), alpha1 = 0.5, beta1 = 1.9, x2 = mean(interestArea2S1$x), y2 = mean(interestArea2S1$y), alpha2 = 0.5, beta2 = 1.9)
interestArea2S1 <- interestArea2 %>%
filter(x>4110 & x<4120 & y>4177 & y<4187)
interestArea2S2 <- interestArea2 %>%
filter(x>4124 & x<4134 & y>4173 & y<4183)
nrow(interestArea2S1)
nrow(interestArea2S2)
MM2MOFFAT <- function(params, x, y){
#component density 1
lambda1 <- params[[1]]
x1 <- params[[2]]
y1 <- params[[3]]
alpha1 <- params[[4]]
beta1 <- params[[5]]
#component density 2
#lambda2 <- params[[6]]
x2 <- params[[6]]
y2 <- params[[7]]
alpha2 <- params[[8]]
beta2 <- params[[9]]
#restrictions
alpha1 <- pmax(alpha1, 1e-6)
beta1 <- pmax(beta1, 1 + 1e-6)
alpha2 <- pmax(alpha2, 1e-6)
beta2 <- pmax(beta2, 1 + 1e-6)
lambda1 <- pmin(lambda1, 1)
lambda1 <- pmax(lambda1, 0)
lambda2 = 1 - lambda1
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
return(lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2))
}
library(pracma)
#test
testParams <- c(lambda1 = 0.5, x1 = 1, y1 = 4, alpha1 = 0.4, beta1 = 2, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral <- integral2(MM2MOFFAT, xmin = -40, xmax = 40, ymin = -40, ymax = 40, params = testParams)[[1]]
MixtureIntegral
#test2
testParams2 <- c(lambda1 = 0.7, x1 = 40, y1 = 33, alpha1 = 1.2, beta1 = 1.7, x2 = 3, y2 = -2, alpha2 = 1.2, beta2 = 1.3)
MixtureIntegral2 <- integral2(MM2MOFFAT, xmin = -100, xmax = 100, ymin = -100, ymax = 100, params = testParams2)[[1]]
MixtureIntegral2
#test3
testParams3 <- c(lambda1 = 0.55, x1 = 0, y1 = 0, alpha1 = 1.2, beta1 = 2, x2 = 2, y2 = 2, alpha2 = 1.2, beta2 = 2)
MixtureIntegral3 <- integral2(MM2MOFFAT, xmin = -50, xmax = 50, ymin = -50, ymax = 50, params = testParams3)[[1]]
MixtureIntegral3
initialParams <- c(lambda1 = 0.7, x1 = 4115.261, y1 = 4051.904, alpha1 = 0.683, beta1 = 1.9, x2 = 4124, y2 = 4063, alpha2 = 0.5, beta2 = 1.9)
lowerbounds = c(0, 3000, 3000, 1e-6, 1+1e-6, 3000, 3000, 1e-6, 1+1e-6)
upperbounds = c(1, 5000, 5000, Inf, Inf, 5000, 5000, Inf, Inf)
MMresult <- optim(par = initialParams, fn = NLLMM2MOFFAT, gr = derivNLLMM2MOFFAT, x = interestArea$x, y = interestArea$y, method = "L-BFGS-B", upper = upperbounds, lower = lowerbounds)
View(NLLMM2MOFFAT)
View(MM2MOFFAT)
myenv <- new.env()
assign("lambda1", 0.5, envir = myenv)
assign("beta1", 2, envir = myenv)
assign("alpha1", 1, envir = myenv)
assign("x1", 40, envir = myenv)
assign("y1", 20, envir = myenv)
assign("lambda2", 0.5, envir = myenv)
assign("beta2", 1.8, envir = myenv)
assign("alpha2", 1.2, envir = myenv)
assign("x2", 30, envir = myenv)
assign("y2", 30, envir = myenv)
assign("x", 35, envir = myenv)
assign("y", 25, envir = myenv)
f <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
predDensity <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
return(-sum(log(predDensity)))
}
f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
outputnumderiv <- numericDeriv(quote(f(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)), c("lambda1", "x1", "y1", "alpha1", "beta1", "lambda2", "x2", "y2", "alpha2", "beta2"), myenv)
derivf <- function(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y){
#common terms
c1 <- (beta1 - 1)/(pi*alpha1^2)
c2 <- (beta2 - 1)/(pi*alpha2^2)
v1 <- 1+(((x-x1)^2+(y-y1)^2)/alpha1^2)
v2 <- 1+(((x-x2)^2+(y-y2)^2)/alpha2^2)
s1 <- lambda1/(pi*alpha1^2)
s2 <- lambda2/(pi*alpha2^2)
u <- lambda1*c1*v1^(-beta1) + lambda2*c2*v2^(-beta2)
#partial derivatives
dLambda1 <- -sum(c1/(u*v1^beta1))
dLambda2 <- -sum(c2/(u*v2^beta2))
dx1 <- -sum((2*lambda1*c1*beta1*(x-x1))/(u*(alpha1^2)*(v1^(beta1+1))))
dx2 <- -sum((2*lambda2*c2*beta2*(x-x2))/(u*(alpha2^2)*(v2^(beta2+1))))
dy1 <- -sum((2*lambda1*c1*beta1*(y-y1))/(u*(alpha1^2)*(v1^(beta1+1))))
dy2 <- -sum((2*lambda2*c2*beta2*(y-y2))/(u*(alpha2^2)*(v2^(beta2+1))))
# dAlpha1 <- -sum((2*lambda1*(beta1^2 - 1))/(u*pi*(v1^beta1)*(alpha1^3)))
# dAlpha2 <- -sum((2*lambda2*(beta2^2 - 1))/(u*pi*(v2^beta2)*(alpha2^3)))
dAlpha1 <- -sum(((2*lambda1*(beta1 - 1)/(pi*alpha1^3*v1^beta1))*((beta1*((x-x1)^2 + (y-y1)^2)/(v1*alpha1^2))-1))/u)
dAlpha2 <- -sum(((2*lambda2*(beta2 - 1)/(pi*alpha2^3*v2^beta2))*((beta2*((x-x2)^2 + (y-y2)^2)/(v2*alpha2^2))-1))/u)
dBeta1 <- -sum((s1*(1+log(v1)-beta1*log(v1)))/(u*v1^beta1))
dBeta2 <- -sum((s2*(1+log(v2)-beta2*log(v2)))/(u*v2^beta2))
return(c(dLambda1, dx1, dy1, dAlpha1, dBeta1, dLambda2, dx2, dy2, dAlpha2, dBeta2))
}
outputderivf <- derivf(lambda1, beta1, alpha1, x1, y1, lambda2, beta2, alpha2, x2, y2, x, y)
outputnumderiv
outputderivf
